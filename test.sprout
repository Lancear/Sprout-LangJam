
class bruh {
    mut a:u8 = 23;
    let b:u8 = 32;
    
    event something(Type1, Type2);
}

module crap {
    import penis;
    
    class bruh {
        mut a:u8 = 23;
        let b:u8 = 32;
        
        event something(Type1, Type2);
        
        fn smth():void {
            emit something(nil, nil);
            return 2, 3;
        }
    } //broh
    
    fn main():u8 {
        return penis.CONSTANT;
    }
}

/* asdjkhasdl */

/*

asdjkhasdl

*/

module penis {
    let CONSTANT:u8 = 1337;
    
    fn test(arg1:mut par1, arg2:&par2):void {
        mut x:par2 = 3;
        let y:par1 = 4;
        mut z:par3 = y;

        if(1) {
            return (5 * x + (y + z) - 5 / y) % 256;
        } else {
            if(0)
                return 3;
            else
                if(2)
                    return 6;
        }
    }

    fn test2(arg1:&mut par1  .name, arg2:par2   .very.           long    . type .  name):void {
        while(arg1)
            arg1 = dispatch(x, y, z);
    }
    
    fn test3(i:u8, j:u8):void {
        for(mut a = 0; a < i; a = a + 1)
            dispatch();
    }
    
    fn test4():void {
        mut a = 13;
        
        a++;
        
        a = ++a + a++;
    
        do {
            test3();
        } while(test());
        
        a += a -= a *= a /= a %= a &= a |= a ^= ~-~-~-a;

        do
            test3();
        while(test());
    }
    
    
    fn test5():u8 {
        @some.object(broh1, broh2) {
            return broh1, broh2;
        }

        return 2 ? 3 ? 4 : 5 : 6;
    }

    fn bitop(a:mut u8):u8 {
        return a>>3<<4&5|8^9;
    }

    fn log(a:&mut u8):u8 {
        return !a&&a||a&&!a;

        call(2, 3, 4);

        return 2, 3;
    }
}

